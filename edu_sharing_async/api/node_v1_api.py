# coding: utf-8

"""
    edu-sharing Repository REST API

    The public restful API of the edu-sharing repository.  # noqa: E501

    OpenAPI spec version: 1.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from edu_sharing_async.api_client import ApiClient


class NODEV1Api(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_aspects(self, body, repository, node, **kwargs):  # noqa: E501
        """Add aspect to node.  # noqa: E501

        Add aspect to node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_aspects(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: aspect name, e.g. ccm:lomreplication (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_aspects_with_http_info(body, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.add_aspects_with_http_info(body, repository, node, **kwargs)  # noqa: E501
            return data

    def add_aspects_with_http_info(self, body, repository, node, **kwargs):  # noqa: E501
        """Add aspect to node.  # noqa: E501

        Add aspect to node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_aspects_with_http_info(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: aspect name, e.g. ccm:lomreplication (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_aspects" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_aspects`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `add_aspects`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `add_aspects`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/aspects', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_workflow_history(self, body, repository, node, **kwargs):  # noqa: E501
        """Add workflow.  # noqa: E501

        Add workflow entry to node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_workflow_history(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorkflowHistory body: The history entry to put (editor and time can be null and will be filled automatically) (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_workflow_history_with_http_info(body, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.add_workflow_history_with_http_info(body, repository, node, **kwargs)  # noqa: E501
            return data

    def add_workflow_history_with_http_info(self, body, repository, node, **kwargs):  # noqa: E501
        """Add workflow.  # noqa: E501

        Add workflow entry to node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_workflow_history_with_http_info(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WorkflowHistory body: The history entry to put (editor and time can be null and will be filled automatically) (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_workflow_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_workflow_history`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `add_workflow_history`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `add_workflow_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/workflow', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_content(self, mimetype, repository, node, **kwargs):  # noqa: E501
        """Change content of node.  # noqa: E501

        Change content of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_content(mimetype, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mimetype: MIME-Type (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str file:
        :param str version_comment: comment, leave empty = no new version, otherwise new version is generated
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_content_with_http_info(mimetype, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.change_content_with_http_info(mimetype, repository, node, **kwargs)  # noqa: E501
            return data

    def change_content_with_http_info(self, mimetype, repository, node, **kwargs):  # noqa: E501
        """Change content of node.  # noqa: E501

        Change content of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_content_with_http_info(mimetype, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mimetype: MIME-Type (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str file:
        :param str version_comment: comment, leave empty = no new version, otherwise new version is generated
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mimetype', 'repository', 'node', 'file', 'version_comment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mimetype' is set
        if ('mimetype' not in params or
                params['mimetype'] is None):
            raise ValueError("Missing the required parameter `mimetype` when calling `change_content`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `change_content`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `change_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'version_comment' in params:
            query_params.append(('versionComment', params['version_comment']))  # noqa: E501
        if 'mimetype' in params:
            query_params.append(('mimetype', params['mimetype']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/content', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_content_as_text(self, repository, node, mimetype, **kwargs):  # noqa: E501
        """Change content of node as text.  # noqa: E501

        Change content of node as text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_content_as_text(repository, node, mimetype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str mimetype: MIME-Type (required)
        :param str version_comment: comment, leave empty = no new version, otherwise new version is generated
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_content_as_text_with_http_info(repository, node, mimetype, **kwargs)  # noqa: E501
        else:
            (data) = self.change_content_as_text_with_http_info(repository, node, mimetype, **kwargs)  # noqa: E501
            return data

    def change_content_as_text_with_http_info(self, repository, node, mimetype, **kwargs):  # noqa: E501
        """Change content of node as text.  # noqa: E501

        Change content of node as text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_content_as_text_with_http_info(repository, node, mimetype, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str mimetype: MIME-Type (required)
        :param str version_comment: comment, leave empty = no new version, otherwise new version is generated
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'mimetype', 'version_comment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_content_as_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `change_content_as_text`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `change_content_as_text`")  # noqa: E501
        # verify the required parameter 'mimetype' is set
        if ('mimetype' not in params or
                params['mimetype'] is None):
            raise ValueError("Missing the required parameter `mimetype` when calling `change_content_as_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'version_comment' in params:
            query_params.append(('versionComment', params['version_comment']))  # noqa: E501
        if 'mimetype' in params:
            query_params.append(('mimetype', params['mimetype']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/textContent', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_metadata(self, body, repository, node, **kwargs):  # noqa: E501
        """Change metadata of node.  # noqa: E501

        Change metadata of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_metadata(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_metadata_with_http_info(body, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.change_metadata_with_http_info(body, repository, node, **kwargs)  # noqa: E501
            return data

    def change_metadata_with_http_info(self, body, repository, node, **kwargs):  # noqa: E501
        """Change metadata of node.  # noqa: E501

        Change metadata of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_metadata_with_http_info(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `change_metadata`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `change_metadata`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `change_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/metadata', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_metadata_with_versioning(self, body, version_comment, repository, node, **kwargs):  # noqa: E501
        """Change metadata of node (new version).  # noqa: E501

        Change metadata of node (new version).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_metadata_with_versioning(body, version_comment, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties (required)
        :param str version_comment: comment (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_metadata_with_versioning_with_http_info(body, version_comment, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.change_metadata_with_versioning_with_http_info(body, version_comment, repository, node, **kwargs)  # noqa: E501
            return data

    def change_metadata_with_versioning_with_http_info(self, body, version_comment, repository, node, **kwargs):  # noqa: E501
        """Change metadata of node (new version).  # noqa: E501

        Change metadata of node (new version).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_metadata_with_versioning_with_http_info(body, version_comment, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties (required)
        :param str version_comment: comment (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'version_comment', 'repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_metadata_with_versioning" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `change_metadata_with_versioning`")  # noqa: E501
        # verify the required parameter 'version_comment' is set
        if ('version_comment' not in params or
                params['version_comment'] is None):
            raise ValueError("Missing the required parameter `version_comment` when calling `change_metadata_with_versioning`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `change_metadata_with_versioning`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `change_metadata_with_versioning`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'version_comment' in params:
            query_params.append(('versionComment', params['version_comment']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_preview(self, mimetype, repository, node, **kwargs):  # noqa: E501
        """Change preview of node.  # noqa: E501

        Change preview of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_preview(mimetype, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mimetype: MIME-Type (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str image:
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_preview_with_http_info(mimetype, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.change_preview_with_http_info(mimetype, repository, node, **kwargs)  # noqa: E501
            return data

    def change_preview_with_http_info(self, mimetype, repository, node, **kwargs):  # noqa: E501
        """Change preview of node.  # noqa: E501

        Change preview of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_preview_with_http_info(mimetype, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str mimetype: MIME-Type (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str image:
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mimetype', 'repository', 'node', 'image']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_preview" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mimetype' is set
        if ('mimetype' not in params or
                params['mimetype'] is None):
            raise ValueError("Missing the required parameter `mimetype` when calling `change_preview`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `change_preview`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `change_preview`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'mimetype' in params:
            query_params.append(('mimetype', params['mimetype']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/preview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_template_metadata(self, body, enable, repository, node, **kwargs):  # noqa: E501
        """Set the metadata template for this folder.  # noqa: E501

        All the given metadata will be inherited to child nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_template_metadata(body, enable, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties (required)
        :param bool enable: Is the inherition currently enabled (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_template_metadata_with_http_info(body, enable, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.change_template_metadata_with_http_info(body, enable, repository, node, **kwargs)  # noqa: E501
            return data

    def change_template_metadata_with_http_info(self, body, enable, repository, node, **kwargs):  # noqa: E501
        """Set the metadata template for this folder.  # noqa: E501

        All the given metadata will be inherited to child nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_template_metadata_with_http_info(body, enable, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties (required)
        :param bool enable: Is the inherition currently enabled (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'enable', 'repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_template_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `change_template_metadata`")  # noqa: E501
        # verify the required parameter 'enable' is set
        if ('enable' not in params or
                params['enable'] is None):
            raise ValueError("Missing the required parameter `enable` when calling `change_template_metadata`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `change_template_metadata`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `change_template_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'enable' in params:
            query_params.append(('enable', params['enable']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/metadata/template', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_child(self, body, type, repository, node, **kwargs):  # noqa: E501
        """Create a new child.  # noqa: E501

        Create a new child.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_child(body, type, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties, example: {"{http://www.alfresco.org/model/content/1.0}name": ["test"]} (required)
        :param str type: type of node (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node use -userhome- for userhome or -inbox- for inbox node (required)
        :param list[str] aspects: aspects of node
        :param bool rename_if_exists: rename if the same node name exists
        :param str version_comment: comment, leave empty = no inital version
        :param str assoc_type: Association type, can be empty
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_child_with_http_info(body, type, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.create_child_with_http_info(body, type, repository, node, **kwargs)  # noqa: E501
            return data

    def create_child_with_http_info(self, body, type, repository, node, **kwargs):  # noqa: E501
        """Create a new child.  # noqa: E501

        Create a new child.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_child_with_http_info(body, type, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, list[str]) body: properties, example: {"{http://www.alfresco.org/model/content/1.0}name": ["test"]} (required)
        :param str type: type of node (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node use -userhome- for userhome or -inbox- for inbox node (required)
        :param list[str] aspects: aspects of node
        :param bool rename_if_exists: rename if the same node name exists
        :param str version_comment: comment, leave empty = no inital version
        :param str assoc_type: Association type, can be empty
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'type', 'repository', 'node', 'aspects', 'rename_if_exists', 'version_comment', 'assoc_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_child" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_child`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `create_child`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_child`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `create_child`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'aspects' in params:
            query_params.append(('aspects', params['aspects']))  # noqa: E501
            collection_formats['aspects'] = 'multi'  # noqa: E501
        if 'rename_if_exists' in params:
            query_params.append(('renameIfExists', params['rename_if_exists']))  # noqa: E501
        if 'version_comment' in params:
            query_params.append(('versionComment', params['version_comment']))  # noqa: E501
        if 'assoc_type' in params:
            query_params.append(('assocType', params['assoc_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/children', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_child_by_copying(self, repository, node, source, with_children, **kwargs):  # noqa: E501
        """Create a new child by copying.  # noqa: E501

        Create a new child by copying.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_child_by_copying(repository, node, source, with_children, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (required)
        :param str source: ID of source node (required)
        :param bool with_children: flag for children (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_child_by_copying_with_http_info(repository, node, source, with_children, **kwargs)  # noqa: E501
        else:
            (data) = self.create_child_by_copying_with_http_info(repository, node, source, with_children, **kwargs)  # noqa: E501
            return data

    def create_child_by_copying_with_http_info(self, repository, node, source, with_children, **kwargs):  # noqa: E501
        """Create a new child by copying.  # noqa: E501

        Create a new child by copying.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_child_by_copying_with_http_info(repository, node, source, with_children, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (required)
        :param str source: ID of source node (required)
        :param bool with_children: flag for children (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'source', 'with_children']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_child_by_copying" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_child_by_copying`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `create_child_by_copying`")  # noqa: E501
        # verify the required parameter 'source' is set
        if ('source' not in params or
                params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `create_child_by_copying`")  # noqa: E501
        # verify the required parameter 'with_children' is set
        if ('with_children' not in params or
                params['with_children'] is None):
            raise ValueError("Missing the required parameter `with_children` when calling `create_child_by_copying`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'with_children' in params:
            query_params.append(('withChildren', params['with_children']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/children/_copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_child_by_moving(self, repository, node, source, **kwargs):  # noqa: E501
        """Create a new child by moving.  # noqa: E501

        Create a new child by moving.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_child_by_moving(repository, node, source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (required)
        :param str source: ID of source node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_child_by_moving_with_http_info(repository, node, source, **kwargs)  # noqa: E501
        else:
            (data) = self.create_child_by_moving_with_http_info(repository, node, source, **kwargs)  # noqa: E501
            return data

    def create_child_by_moving_with_http_info(self, repository, node, source, **kwargs):  # noqa: E501
        """Create a new child by moving.  # noqa: E501

        Create a new child by moving.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_child_by_moving_with_http_info(repository, node, source, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (required)
        :param str source: ID of source node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_child_by_moving" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_child_by_moving`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `create_child_by_moving`")  # noqa: E501
        # verify the required parameter 'source' is set
        if ('source' not in params or
                params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `create_child_by_moving`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/children/_move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_fork_of_node(self, repository, node, source, with_children, **kwargs):  # noqa: E501
        """Create a copy of a node by creating a forked version (variant).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fork_of_node(repository, node, source, with_children, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (required)
        :param str source: ID of source node (required)
        :param bool with_children: flag for children (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_fork_of_node_with_http_info(repository, node, source, with_children, **kwargs)  # noqa: E501
        else:
            (data) = self.create_fork_of_node_with_http_info(repository, node, source, with_children, **kwargs)  # noqa: E501
            return data

    def create_fork_of_node_with_http_info(self, repository, node, source, with_children, **kwargs):  # noqa: E501
        """Create a copy of a node by creating a forked version (variant).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_fork_of_node_with_http_info(repository, node, source, with_children, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (required)
        :param str source: ID of source node (required)
        :param bool with_children: flag for children (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'source', 'with_children']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_fork_of_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_fork_of_node`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `create_fork_of_node`")  # noqa: E501
        # verify the required parameter 'source' is set
        if ('source' not in params or
                params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `create_fork_of_node`")  # noqa: E501
        # verify the required parameter 'with_children' is set
        if ('with_children' not in params or
                params['with_children'] is None):
            raise ValueError("Missing the required parameter `with_children` when calling `create_fork_of_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'with_children' in params:
            query_params.append(('withChildren', params['with_children']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/children/_fork', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_share(self, repository, node, **kwargs):  # noqa: E501
        """Create a share for a node.  # noqa: E501

        Create a new share for a node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_share(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param int expiry_date: expiry date for this share, leave empty or -1 for unlimited
        :param str password: password for this share, use none to not use a password
        :return: NodeShare
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_share_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.create_share_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def create_share_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Create a share for a node.  # noqa: E501

        Create a new share for a node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_share_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param int expiry_date: expiry date for this share, leave empty or -1 for unlimited
        :param str password: password for this share, use none to not use a password
        :return: NodeShare
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'expiry_date', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_share`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `create_share`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'expiry_date' in params:
            query_params.append(('expiryDate', params['expiry_date']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/shares', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeShare',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete(self, repository, node, **kwargs):  # noqa: E501
        """Delete node.  # noqa: E501

        Delete node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param bool recycle: move the node to recycle
        :param str protocol: protocol
        :param str store: store
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def delete_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Delete node.  # noqa: E501

        Delete node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param bool recycle: move the node to recycle
        :param str protocol: protocol
        :param str store: store
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'recycle', 'protocol', 'store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'recycle' in params:
            query_params.append(('recycle', params['recycle']))  # noqa: E501
        if 'protocol' in params:
            query_params.append(('protocol', params['protocol']))  # noqa: E501
        if 'store' in params:
            query_params.append(('store', params['store']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_preview(self, repository, node, **kwargs):  # noqa: E501
        """Delete preview of node.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_preview(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_preview_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_preview_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def delete_preview_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Delete preview of node.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_preview_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_preview" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_preview`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `delete_preview`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/preview', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_assocs(self, repository, node, direction, **kwargs):  # noqa: E501
        """Get related nodes.  # noqa: E501

        Get nodes related based on an assoc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assocs(repository, node, direction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str direction: Either where the given node should be the \"SOURCE\" or the \"TARGET\" (required)
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param str assoc_name: Association name (e.g. ccm:forkio).
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_assocs_with_http_info(repository, node, direction, **kwargs)  # noqa: E501
        else:
            (data) = self.get_assocs_with_http_info(repository, node, direction, **kwargs)  # noqa: E501
            return data

    def get_assocs_with_http_info(self, repository, node, direction, **kwargs):  # noqa: E501
        """Get related nodes.  # noqa: E501

        Get nodes related based on an assoc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assocs_with_http_info(repository, node, direction, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str direction: Either where the given node should be the \"SOURCE\" or the \"TARGET\" (required)
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param str assoc_name: Association name (e.g. ccm:forkio).
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'direction', 'max_items', 'skip_count', 'sort_properties', 'sort_ascending', 'assoc_name', 'property_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_assocs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_assocs`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_assocs`")  # noqa: E501
        # verify the required parameter 'direction' is set
        if ('direction' not in params or
                params['direction'] is None):
            raise ValueError("Missing the required parameter `direction` when calling `get_assocs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'max_items' in params:
            query_params.append(('maxItems', params['max_items']))  # noqa: E501
        if 'skip_count' in params:
            query_params.append(('skipCount', params['skip_count']))  # noqa: E501
        if 'sort_properties' in params:
            query_params.append(('sortProperties', params['sort_properties']))  # noqa: E501
            collection_formats['sortProperties'] = 'multi'  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sortAscending', params['sort_ascending']))  # noqa: E501
            collection_formats['sortAscending'] = 'multi'  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'assoc_name' in params:
            query_params.append(('assocName', params['assoc_name']))  # noqa: E501
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/assocs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_children(self, repository, node, **kwargs):  # noqa: E501
        """Get children of node.  # noqa: E501

        Get children of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_children(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (or \"-userhome-\" for home directory of current user, \"-shared_files-\" for shared folders, \"-to_me_shared_files\" for shared files for the user,\"-my_shared_files-\" for files shared by the user, \"-inbox-\" for the inbox, \"-workflow_receive-\" for files assigned by workflow, \"-saved_search-\" for saved searches of the user) (required)
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] filter: filter by type files,folders
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param str assoc_name: Filter for a specific association. May be empty
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_children_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_children_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_children_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get children of node.  # noqa: E501

        Get children of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_children_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of parent node (or \"-userhome-\" for home directory of current user, \"-shared_files-\" for shared folders, \"-to_me_shared_files\" for shared files for the user,\"-my_shared_files-\" for files shared by the user, \"-inbox-\" for the inbox, \"-workflow_receive-\" for files assigned by workflow, \"-saved_search-\" for saved searches of the user) (required)
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] filter: filter by type files,folders
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param str assoc_name: Filter for a specific association. May be empty
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'max_items', 'skip_count', 'filter', 'sort_properties', 'sort_ascending', 'assoc_name', 'property_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_children" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_children`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_children`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'max_items' in params:
            query_params.append(('maxItems', params['max_items']))  # noqa: E501
        if 'skip_count' in params:
            query_params.append(('skipCount', params['skip_count']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
            collection_formats['filter'] = 'multi'  # noqa: E501
        if 'sort_properties' in params:
            query_params.append(('sortProperties', params['sort_properties']))  # noqa: E501
            collection_formats['sortProperties'] = 'multi'  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sortAscending', params['sort_ascending']))  # noqa: E501
            collection_formats['sortAscending'] = 'multi'  # noqa: E501
        if 'assoc_name' in params:
            query_params.append(('assocName', params['assoc_name']))  # noqa: E501
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/children', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metadata(self, repository, node, **kwargs):  # noqa: E501
        """Get metadata of node.  # noqa: E501

        Get metadata of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_metadata_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_metadata_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_metadata_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get metadata of node.  # noqa: E501

        Get metadata of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'property_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_metadata`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nodes(self, repository, query, **kwargs):  # noqa: E501
        """Searching nodes.  # noqa: E501

        Searching nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nodes(repository, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str query: lucene query (required)
        :param list[str] facettes: facettes
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: SearchResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nodes_with_http_info(repository, query, **kwargs)  # noqa: E501
        else:
            (data) = self.get_nodes_with_http_info(repository, query, **kwargs)  # noqa: E501
            return data

    def get_nodes_with_http_info(self, repository, query, **kwargs):  # noqa: E501
        """Searching nodes.  # noqa: E501

        Searching nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nodes_with_http_info(repository, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str query: lucene query (required)
        :param list[str] facettes: facettes
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: SearchResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'query', 'facettes', 'max_items', 'skip_count', 'sort_properties', 'sort_ascending', 'property_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nodes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_nodes`")  # noqa: E501
        # verify the required parameter 'query' is set
        if ('query' not in params or
                params['query'] is None):
            raise ValueError("Missing the required parameter `query` when calling `get_nodes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'facettes' in params:
            query_params.append(('facettes', params['facettes']))  # noqa: E501
            collection_formats['facettes'] = 'multi'  # noqa: E501
        if 'max_items' in params:
            query_params.append(('maxItems', params['max_items']))  # noqa: E501
        if 'skip_count' in params:
            query_params.append(('skipCount', params['skip_count']))  # noqa: E501
        if 'sort_properties' in params:
            query_params.append(('sortProperties', params['sort_properties']))  # noqa: E501
            collection_formats['sortProperties'] = 'multi'  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sortAscending', params['sort_ascending']))  # noqa: E501
            collection_formats['sortAscending'] = 'multi'  # noqa: E501
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_notify_list(self, repository, node, **kwargs):  # noqa: E501
        """Get notifys (sharing history) of the node.  # noqa: E501

        Ordered by the time of each notify  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_notify_list(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: list[NotifyEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_notify_list_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_notify_list_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_notify_list_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get notifys (sharing history) of the node.  # noqa: E501

        Ordered by the time of each notify  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_notify_list_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: list[NotifyEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_notify_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_notify_list`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_notify_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/notifys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NotifyEntry]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_parents(self, repository, node, **kwargs):  # noqa: E501
        """Get parents of node.  # noqa: E501

        Get all parents metadata + own metadata of node. Index 0 is always the current node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_parents(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :param bool full_path: activate to return the full alfresco path, otherwise the path for the user home is resolved
        :return: ParentEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_parents_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_parents_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_parents_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get parents of node.  # noqa: E501

        Get all parents metadata + own metadata of node. Index 0 is always the current node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_parents_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :param bool full_path: activate to return the full alfresco path, otherwise the path for the user home is resolved
        :return: ParentEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'property_filter', 'full_path']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_parents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_parents`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_parents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501
        if 'full_path' in params:
            query_params.append(('fullPath', params['full_path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/parents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ParentEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_permission(self, repository, node, **kwargs):  # noqa: E501
        """Get all permission of node.  # noqa: E501

        Get all permission of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_permission(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodePermissionEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_permission_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_permission_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_permission_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get all permission of node.  # noqa: E501

        Get all permission of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_permission_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodePermissionEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_permission`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/permissions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodePermissionEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_published_copies(self, repository, node, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        Get all published copies of the current node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_published_copies(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_published_copies_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_published_copies_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_published_copies_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        Get all published copies of the current node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_published_copies_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_published_copies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_published_copies`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_published_copies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/publish', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_shares(self, repository, node, **kwargs):  # noqa: E501
        """Get shares of node.  # noqa: E501

        Get list of shares (via mail/token) for a node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shares(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str email: Filter for a specific email or use LINK for link shares (Optional)
        :return: list[NodeShare]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_shares_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_shares_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_shares_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get shares of node.  # noqa: E501

        Get list of shares (via mail/token) for a node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_shares_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str email: Filter for a specific email or use LINK for link shares (Optional)
        :return: list[NodeShare]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_shares" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_shares`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_shares`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/shares', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NodeShare]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template_metadata(self, repository, node, **kwargs):  # noqa: E501
        """Get the metadata template + status for this folder.  # noqa: E501

        All the given metadata will be inherited to child nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_metadata(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_template_metadata_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_template_metadata_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_template_metadata_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get the metadata template + status for this folder.  # noqa: E501

        All the given metadata will be inherited to child nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_metadata_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_template_metadata`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_template_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/metadata/template', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_text_content(self, repository, node, **kwargs):  # noqa: E501
        """Get the text content of a document.  # noqa: E501

        May fails with 500 if the node can not be read.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_text_content(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeText
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_text_content_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_text_content_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_text_content_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get the text content of a document.  # noqa: E501

        May fails with 500 if the node can not be read.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_text_content_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeText
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_text_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_text_content`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_text_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/textContent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeText',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_version_metadata(self, repository, node, major, minor, **kwargs):  # noqa: E501
        """Get metadata of node version.  # noqa: E501

        Get metadata of node version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_metadata(repository, node, major, minor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param int major: major version (required)
        :param int minor: minor version (required)
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeVersionEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_version_metadata_with_http_info(repository, node, major, minor, **kwargs)  # noqa: E501
        else:
            (data) = self.get_version_metadata_with_http_info(repository, node, major, minor, **kwargs)  # noqa: E501
            return data

    def get_version_metadata_with_http_info(self, repository, node, major, minor, **kwargs):  # noqa: E501
        """Get metadata of node version.  # noqa: E501

        Get metadata of node version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_metadata_with_http_info(repository, node, major, minor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param int major: major version (required)
        :param int minor: minor version (required)
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :return: NodeVersionEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'major', 'minor', 'property_filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_version_metadata`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_version_metadata`")  # noqa: E501
        # verify the required parameter 'major' is set
        if ('major' not in params or
                params['major'] is None):
            raise ValueError("Missing the required parameter `major` when calling `get_version_metadata`")  # noqa: E501
        # verify the required parameter 'minor' is set
        if ('minor' not in params or
                params['minor'] is None):
            raise ValueError("Missing the required parameter `minor` when calling `get_version_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'major' in params:
            path_params['major'] = params['major']  # noqa: E501
        if 'minor' in params:
            path_params['minor'] = params['minor']  # noqa: E501

        query_params = []
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/versions/{major}/{minor}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeVersionEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_versions(self, repository, node, **kwargs):  # noqa: E501
        """Get all versions of node.  # noqa: E501

        Get all versions of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versions(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeVersionRefEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_versions_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_versions_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_versions_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get all versions of node.  # noqa: E501

        Get all versions of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versions_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeVersionRefEntries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_versions`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeVersionRefEntries',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workflow_history(self, repository, node, **kwargs):  # noqa: E501
        """Get workflow history.  # noqa: E501

        Get workflow history of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_history(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: list[WorkflowHistory]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_workflow_history_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.get_workflow_history_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def get_workflow_history_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Get workflow history.  # noqa: E501

        Get workflow history of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workflow_history_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: list[WorkflowHistory]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_workflow_history`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_workflow_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/workflow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowHistory]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def has_permission(self, repository, node, user, **kwargs):  # noqa: E501
        """Which permissions has user/group for node.  # noqa: E501

        Check for actual permissions (also when user is in groups) for a specific node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.has_permission(repository, node, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str user: Authority (user/group) to check (use \"-me-\" for current user (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.has_permission_with_http_info(repository, node, user, **kwargs)  # noqa: E501
        else:
            (data) = self.has_permission_with_http_info(repository, node, user, **kwargs)  # noqa: E501
            return data

    def has_permission_with_http_info(self, repository, node, user, **kwargs):  # noqa: E501
        """Which permissions has user/group for node.  # noqa: E501

        Check for actual permissions (also when user is in groups) for a specific node  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.has_permission_with_http_info(repository, node, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str user: Authority (user/group) to check (use \"-me-\" for current user (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method has_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `has_permission`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `has_permission`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `has_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/permissions/{user}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_node(self, repository, node, parent, **kwargs):  # noqa: E501
        """Import node  # noqa: E501

        Import a node from a foreign repository to the local repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_node(repository, node, parent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: The id of the foreign repository (required)
        :param str node: ID of node (required)
        :param str parent: Parent node where to store it locally, may also use -userhome- or -inbox- (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_node_with_http_info(repository, node, parent, **kwargs)  # noqa: E501
        else:
            (data) = self.import_node_with_http_info(repository, node, parent, **kwargs)  # noqa: E501
            return data

    def import_node_with_http_info(self, repository, node, parent, **kwargs):  # noqa: E501
        """Import node  # noqa: E501

        Import a node from a foreign repository to the local repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_node_with_http_info(repository, node, parent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: The id of the foreign repository (required)
        :param str node: ID of node (required)
        :param str parent: Parent node where to store it locally, may also use -userhome- or -inbox- (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'parent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `import_node`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `import_node`")  # noqa: E501
        # verify the required parameter 'parent' is set
        if ('parent' not in params or
                params['parent'] is None):
            raise ValueError("Missing the required parameter `parent` when calling `import_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'parent' in params:
            query_params.append(('parent', params['parent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def islocked(self, repository, node, **kwargs):  # noqa: E501
        """locked status of a node.  # noqa: E501

        locked status of a node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.islocked(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeLocked
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.islocked_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.islocked_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def islocked_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """locked status of a node.  # noqa: E501

        locked status of a node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.islocked_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeLocked
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method islocked" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `islocked`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `islocked`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/lock/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeLocked',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def prepare_usage(self, repository, node, **kwargs):  # noqa: E501
        """create remote object and get properties.  # noqa: E501

        create remote object and get properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.prepare_usage(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.prepare_usage_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.prepare_usage_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def prepare_usage_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """create remote object and get properties.  # noqa: E501

        create remote object and get properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.prepare_usage_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeRemote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method prepare_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `prepare_usage`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `prepare_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/prepareUsage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeRemote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_copy(self, repository, node, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        Create a published copy of the current node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_copy(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.publish_copy_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.publish_copy_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def publish_copy_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Publish  # noqa: E501

        Create a published copy of the current node   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_copy_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `publish_copy`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `publish_copy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/publish', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_share(self, repository, node, share_id, **kwargs):  # noqa: E501
        """Remove share of a node.  # noqa: E501

        Remove the specified share id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_share(repository, node, share_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str share_id: share id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_share_with_http_info(repository, node, share_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_share_with_http_info(repository, node, share_id, **kwargs)  # noqa: E501
            return data

    def remove_share_with_http_info(self, repository, node, share_id, **kwargs):  # noqa: E501
        """Remove share of a node.  # noqa: E501

        Remove the specified share id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_share_with_http_info(repository, node, share_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str share_id: share id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'share_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `remove_share`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `remove_share`")  # noqa: E501
        # verify the required parameter 'share_id' is set
        if ('share_id' not in params or
                params['share_id'] is None):
            raise ValueError("Missing the required parameter `share_id` when calling `remove_share`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'share_id' in params:
            path_params['shareId'] = params['share_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/shares/{shareId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def report_node(self, repository, node, reason, user_email, **kwargs):  # noqa: E501
        """Report the node.  # noqa: E501

        Report a node to notify the admin about an issue)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.report_node(repository, node, reason, user_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str reason: the reason for the report (required)
        :param str user_email: mail of reporting user (required)
        :param str user_comment: additional user comment
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.report_node_with_http_info(repository, node, reason, user_email, **kwargs)  # noqa: E501
        else:
            (data) = self.report_node_with_http_info(repository, node, reason, user_email, **kwargs)  # noqa: E501
            return data

    def report_node_with_http_info(self, repository, node, reason, user_email, **kwargs):  # noqa: E501
        """Report the node.  # noqa: E501

        Report a node to notify the admin about an issue)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.report_node_with_http_info(repository, node, reason, user_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str reason: the reason for the report (required)
        :param str user_email: mail of reporting user (required)
        :param str user_comment: additional user comment
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'reason', 'user_email', 'user_comment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method report_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `report_node`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `report_node`")  # noqa: E501
        # verify the required parameter 'reason' is set
        if ('reason' not in params or
                params['reason'] is None):
            raise ValueError("Missing the required parameter `reason` when calling `report_node`")  # noqa: E501
        # verify the required parameter 'user_email' is set
        if ('user_email' not in params or
                params['user_email'] is None):
            raise ValueError("Missing the required parameter `user_email` when calling `report_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'user_email' in params:
            query_params.append(('userEmail', params['user_email']))  # noqa: E501
        if 'user_comment' in params:
            query_params.append(('userComment', params['user_comment']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/report', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revert_version(self, repository, node, major, minor, **kwargs):  # noqa: E501
        """Revert to node version.  # noqa: E501

        Revert to node version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revert_version(repository, node, major, minor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param int major: major version (required)
        :param int minor: minor version (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.revert_version_with_http_info(repository, node, major, minor, **kwargs)  # noqa: E501
        else:
            (data) = self.revert_version_with_http_info(repository, node, major, minor, **kwargs)  # noqa: E501
            return data

    def revert_version_with_http_info(self, repository, node, major, minor, **kwargs):  # noqa: E501
        """Revert to node version.  # noqa: E501

        Revert to node version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revert_version_with_http_info(repository, node, major, minor, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param int major: major version (required)
        :param int minor: minor version (required)
        :return: NodeEntry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'major', 'minor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revert_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `revert_version`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `revert_version`")  # noqa: E501
        # verify the required parameter 'major' is set
        if ('major' not in params or
                params['major'] is None):
            raise ValueError("Missing the required parameter `major` when calling `revert_version`")  # noqa: E501
        # verify the required parameter 'minor' is set
        if ('minor' not in params or
                params['minor'] is None):
            raise ValueError("Missing the required parameter `minor` when calling `revert_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'major' in params:
            path_params['major'] = params['major']  # noqa: E501
        if 'minor' in params:
            path_params['minor'] = params['minor']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/versions/{major}/{minor}/_revert', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeEntry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_owner(self, repository, node, **kwargs):  # noqa: E501
        """Set owner of node.  # noqa: E501

        Set owner of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_owner(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str username: username
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_owner_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.set_owner_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def set_owner_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """Set owner of node.  # noqa: E501

        Set owner of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_owner_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str username: username
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_owner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `set_owner`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `set_owner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/owner', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_permission(self, body, send_mail, send_copy, repository, node, **kwargs):  # noqa: E501
        """Set local permissions of node.  # noqa: E501

        Set local permissions of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_permission(body, send_mail, send_copy, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ACL body: permissions (required)
        :param bool send_mail: sendMail (required)
        :param bool send_copy: sendCopy (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str mailtext: mailtext
        :param bool create_handle: createHandle
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_permission_with_http_info(body, send_mail, send_copy, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.set_permission_with_http_info(body, send_mail, send_copy, repository, node, **kwargs)  # noqa: E501
            return data

    def set_permission_with_http_info(self, body, send_mail, send_copy, repository, node, **kwargs):  # noqa: E501
        """Set local permissions of node.  # noqa: E501

        Set local permissions of node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_permission_with_http_info(body, send_mail, send_copy, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ACL body: permissions (required)
        :param bool send_mail: sendMail (required)
        :param bool send_copy: sendCopy (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str mailtext: mailtext
        :param bool create_handle: createHandle
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'send_mail', 'send_copy', 'repository', 'node', 'mailtext', 'create_handle']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_permission`")  # noqa: E501
        # verify the required parameter 'send_mail' is set
        if ('send_mail' not in params or
                params['send_mail'] is None):
            raise ValueError("Missing the required parameter `send_mail` when calling `set_permission`")  # noqa: E501
        # verify the required parameter 'send_copy' is set
        if ('send_copy' not in params or
                params['send_copy'] is None):
            raise ValueError("Missing the required parameter `send_copy` when calling `set_permission`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `set_permission`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `set_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if 'mailtext' in params:
            query_params.append(('mailtext', params['mailtext']))  # noqa: E501
        if 'send_mail' in params:
            query_params.append(('sendMail', params['send_mail']))  # noqa: E501
        if 'send_copy' in params:
            query_params.append(('sendCopy', params['send_copy']))  # noqa: E501
        if 'create_handle' in params:
            query_params.append(('createHandle', params['create_handle']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/permissions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_property(self, repository, node, _property, **kwargs):  # noqa: E501
        """Set single property of node.  # noqa: E501

        When the property is unset (null), it will be removed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_property(repository, node, _property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str _property: property (required)
        :param str value: value
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_property_with_http_info(repository, node, _property, **kwargs)  # noqa: E501
        else:
            (data) = self.set_property_with_http_info(repository, node, _property, **kwargs)  # noqa: E501
            return data

    def set_property_with_http_info(self, repository, node, _property, **kwargs):  # noqa: E501
        """Set single property of node.  # noqa: E501

        When the property is unset (null), it will be removed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_property_with_http_info(repository, node, _property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str _property: property (required)
        :param str value: value
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', '_property', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `set_property`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `set_property`")  # noqa: E501
        # verify the required parameter '_property' is set
        if ('_property' not in params or
                params['_property'] is None):
            raise ValueError("Missing the required parameter `_property` when calling `set_property`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []
        if '_property' in params:
            query_params.append(('property', params['_property']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/property', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_x_api_data(self, body, repository, node, **kwargs):  # noqa: E501
        """Store xApi-Conform data for a given node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_x_api_data(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: xApi conform json data (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_x_api_data_with_http_info(body, repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.store_x_api_data_with_http_info(body, repository, node, **kwargs)  # noqa: E501
            return data

    def store_x_api_data_with_http_info(self, body, repository, node, **kwargs):  # noqa: E501
        """Store xApi-Conform data for a given node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_x_api_data_with_http_info(body, repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: xApi conform json data (required)
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_x_api_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `store_x_api_data`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `store_x_api_data`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `store_x_api_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/xapi', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unlock(self, repository, node, **kwargs):  # noqa: E501
        """unlock node.  # noqa: E501

        unlock node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unlock_with_http_info(repository, node, **kwargs)  # noqa: E501
        else:
            (data) = self.unlock_with_http_info(repository, node, **kwargs)  # noqa: E501
            return data

    def unlock_with_http_info(self, repository, node, **kwargs):  # noqa: E501
        """unlock node.  # noqa: E501

        unlock node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unlock_with_http_info(repository, node, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unlock" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `unlock`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `unlock`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/lock/unlock', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_share(self, repository, node, share_id, **kwargs):  # noqa: E501
        """update share of a node.  # noqa: E501

        update the specified share id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_share(repository, node, share_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str share_id: share id (required)
        :param int expiry_date: expiry date for this share, leave empty or -1 for unlimited
        :param str password: new password for share, leave empty if you don't want to change it
        :return: NodeShare
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_share_with_http_info(repository, node, share_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_share_with_http_info(repository, node, share_id, **kwargs)  # noqa: E501
            return data

    def update_share_with_http_info(self, repository, node, share_id, **kwargs):  # noqa: E501
        """update share of a node.  # noqa: E501

        update the specified share id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_share_with_http_info(repository, node, share_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repository: ID of repository (or \"-home-\" for home repository) (required)
        :param str node: ID of node (required)
        :param str share_id: share id (required)
        :param int expiry_date: expiry date for this share, leave empty or -1 for unlimited
        :param str password: new password for share, leave empty if you don't want to change it
        :return: NodeShare
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repository', 'node', 'share_id', 'expiry_date', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `update_share`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `update_share`")  # noqa: E501
        # verify the required parameter 'share_id' is set
        if ('share_id' not in params or
                params['share_id'] is None):
            raise ValueError("Missing the required parameter `share_id` when calling `update_share`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'share_id' in params:
            path_params['shareId'] = params['share_id']  # noqa: E501

        query_params = []
        if 'expiry_date' in params:
            query_params.append(('expiryDate', params['expiry_date']))  # noqa: E501
        if 'password' in params:
            query_params.append(('password', params['password']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/node/v1/nodes/{repository}/{node}/shares/{shareId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NodeShare',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
