# coding: utf-8

"""
    edu-sharing Repository REST API

    The public restful API of the edu-sharing repository.  # noqa: E501

    OpenAPI spec version: 1.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from edu_sharing_client.api_client import ApiClient


class ADMINV1Api(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_application(self, url, **kwargs):  # noqa: E501
        """register/add an application  # noqa: E501

        register the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_application(url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str url: Remote application metadata url (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_application_with_http_info(url, **kwargs)  # noqa: E501
        else:
            (data) = self.add_application_with_http_info(url, **kwargs)  # noqa: E501
            return data

    def add_application_with_http_info(self, url, **kwargs):  # noqa: E501
        """register/add an application  # noqa: E501

        register the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_application_with_http_info(url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str url: Remote application metadata url (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'url' is set
        if ('url' not in params or
                params['url'] is None):
            raise ValueError("Missing the required parameter `url` when calling `add_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'url' in params:
            query_params.append(('url', params['url']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applications', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_application_0(self, xml, **kwargs):  # noqa: E501
        """register/add an application via xml file  # noqa: E501

        register the xml file provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_application_0(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_application_0_with_http_info(xml, **kwargs)  # noqa: E501
        else:
            (data) = self.add_application_0_with_http_info(xml, **kwargs)  # noqa: E501
            return data

    def add_application_0_with_http_info(self, xml, **kwargs):  # noqa: E501
        """register/add an application via xml file  # noqa: E501

        register the xml file provided.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_application_0_with_http_info(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['xml']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_application_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'xml' is set
        if ('xml' not in params or
                params['xml'] is None):
            raise ValueError("Missing the required parameter `xml` when calling `add_application_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'xml' in params:
            local_var_files['xml'] = params['xml']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applications/xml', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_toolpermission(self, name, **kwargs):  # noqa: E501
        """add a new toolpermissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_toolpermission(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Name/ID of toolpermission (required)
        :return: Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_toolpermission_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.add_toolpermission_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def add_toolpermission_with_http_info(self, name, **kwargs):  # noqa: E501
        """add a new toolpermissions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_toolpermission_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Name/ID of toolpermission (required)
        :return: Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_toolpermission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `add_toolpermission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/toolpermissions/add/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Node',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apply_template(self, template, group, **kwargs):  # noqa: E501
        """apply a folder template  # noqa: E501

        apply a folder template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_template(template, group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template: Template Filename (required)
        :param str group: Group name (authority name) (required)
        :param str folder: Folder name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apply_template_with_http_info(template, group, **kwargs)  # noqa: E501
        else:
            (data) = self.apply_template_with_http_info(template, group, **kwargs)  # noqa: E501
            return data

    def apply_template_with_http_info(self, template, group, **kwargs):  # noqa: E501
        """apply a folder template  # noqa: E501

        apply a folder template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apply_template_with_http_info(template, group, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str template: Template Filename (required)
        :param str group: Group name (authority name) (required)
        :param str folder: Folder name
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template', 'group', 'folder']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apply_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template' is set
        if ('template' not in params or
                params['template'] is None):
            raise ValueError("Missing the required parameter `template` when calling `apply_template`")  # noqa: E501
        # verify the required parameter 'group' is set
        if ('group' not in params or
                params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `apply_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'template' in params:
            query_params.append(('template', params['template']))  # noqa: E501
        if 'group' in params:
            query_params.append(('group', params['group']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applyTemplate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_job(self, job, **kwargs):  # noqa: E501
        """cancel a running job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_job(job, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_job_with_http_info(job, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_job_with_http_info(job, **kwargs)  # noqa: E501
            return data

    def cancel_job_with_http_info(self, job, **kwargs):  # noqa: E501
        """cancel a running job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_job_with_http_info(job, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job' is set
        if ('job' not in params or
                params['job'] is None):
            raise ValueError("Missing the required parameter `job` when calling `cancel_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job' in params:
            path_params['job'] = params['job']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/jobs/{job}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_logging(self, name, loglevel, **kwargs):  # noqa: E501
        """Change the loglevel for classes at runtime.  # noqa: E501

        Root appenders are used. Check the appender treshold.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_logging(name, loglevel, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :param str loglevel: loglevel (required)
        :param str appender: appender
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_logging_with_http_info(name, loglevel, **kwargs)  # noqa: E501
        else:
            (data) = self.change_logging_with_http_info(name, loglevel, **kwargs)  # noqa: E501
            return data

    def change_logging_with_http_info(self, name, loglevel, **kwargs):  # noqa: E501
        """Change the loglevel for classes at runtime.  # noqa: E501

        Root appenders are used. Check the appender treshold.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_logging_with_http_info(name, loglevel, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :param str loglevel: loglevel (required)
        :param str appender: appender
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'loglevel', 'appender']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_logging" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `change_logging`")  # noqa: E501
        # verify the required parameter 'loglevel' is set
        if ('loglevel' not in params or
                params['loglevel'] is None):
            raise ValueError("Missing the required parameter `loglevel` when calling `change_logging`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'loglevel' in params:
            query_params.append(('loglevel', params['loglevel']))  # noqa: E501
        if 'appender' in params:
            query_params.append(('appender', params['appender']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/log', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_person(self, username, **kwargs):  # noqa: E501
        """delete persons  # noqa: E501

        delete the given persons. Their status must be set to \"todelete\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_person(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] username: names of the users to delete (required)
        :param PersonDeleteOptions body: options object what and how to delete user contents
        :return: PersonReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_person_with_http_info(username, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_person_with_http_info(username, **kwargs)  # noqa: E501
            return data

    def delete_person_with_http_info(self, username, **kwargs):  # noqa: E501
        """delete persons  # noqa: E501

        delete the given persons. Their status must be set to \"todelete\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_person_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] username: names of the users to delete (required)
        :param PersonDeleteOptions body: options object what and how to delete user contents
        :return: PersonReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_person" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `delete_person`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
            collection_formats['username'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/deletePersons', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PersonReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_by_lucene(self, **kwargs):  # noqa: E501
        """Search for custom lucene query and choose specific properties to load  # noqa: E501

        e.g. @cm\\:name:\"*\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_by_lucene(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: query
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param list[str] properties: properties to fetch, use parent::<property> to include parent property values
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_by_lucene_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.export_by_lucene_with_http_info(**kwargs)  # noqa: E501
            return data

    def export_by_lucene_with_http_info(self, **kwargs):  # noqa: E501
        """Search for custom lucene query and choose specific properties to load  # noqa: E501

        e.g. @cm\\:name:\"*\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_by_lucene_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: query
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param list[str] properties: properties to fetch, use parent::<property> to include parent property values
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query', 'sort_properties', 'sort_ascending', 'properties']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_by_lucene" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'sort_properties' in params:
            query_params.append(('sortProperties', params['sort_properties']))  # noqa: E501
            collection_formats['sortProperties'] = 'multi'  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sortAscending', params['sort_ascending']))  # noqa: E501
            collection_formats['sortAscending'] = 'multi'  # noqa: E501
        if 'properties' in params:
            query_params.append(('properties', params['properties']))  # noqa: E501
            collection_formats['properties'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/lucene/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_lom(self, filter_query, target_dir, sub_object_handler, **kwargs):  # noqa: E501
        """Export Nodes with LOM Metadata Format  # noqa: E501

        Export Nodes with LOM Metadata Format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_lom(filter_query, target_dir, sub_object_handler, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_query: filterQuery (required)
        :param str target_dir: targetDir (required)
        :param bool sub_object_handler: subObjectHandler (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_lom_with_http_info(filter_query, target_dir, sub_object_handler, **kwargs)  # noqa: E501
        else:
            (data) = self.export_lom_with_http_info(filter_query, target_dir, sub_object_handler, **kwargs)  # noqa: E501
            return data

    def export_lom_with_http_info(self, filter_query, target_dir, sub_object_handler, **kwargs):  # noqa: E501
        """Export Nodes with LOM Metadata Format  # noqa: E501

        Export Nodes with LOM Metadata Format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_lom_with_http_info(filter_query, target_dir, sub_object_handler, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_query: filterQuery (required)
        :param str target_dir: targetDir (required)
        :param bool sub_object_handler: subObjectHandler (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_query', 'target_dir', 'sub_object_handler']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_lom" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filter_query' is set
        if ('filter_query' not in params or
                params['filter_query'] is None):
            raise ValueError("Missing the required parameter `filter_query` when calling `export_lom`")  # noqa: E501
        # verify the required parameter 'target_dir' is set
        if ('target_dir' not in params or
                params['target_dir'] is None):
            raise ValueError("Missing the required parameter `target_dir` when calling `export_lom`")  # noqa: E501
        # verify the required parameter 'sub_object_handler' is set
        if ('sub_object_handler' not in params or
                params['sub_object_handler'] is None):
            raise ValueError("Missing the required parameter `sub_object_handler` when calling `export_lom`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_query' in params:
            query_params.append(('filterQuery', params['filter_query']))  # noqa: E501
        if 'target_dir' in params:
            query_params.append(('targetDir', params['target_dir']))  # noqa: E501
        if 'sub_object_handler' in params:
            query_params.append(('subObjectHandler', params['sub_object_handler']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/export/lom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_toolpermissions(self, authority, **kwargs):  # noqa: E501
        """get all toolpermissions for an authority  # noqa: E501

        Returns explicit (rights set for this authority) + effective (resulting rights for this authority) toolpermission  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_toolpermissions(authority, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authority: Authority to load (user or group) (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_toolpermissions_with_http_info(authority, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_toolpermissions_with_http_info(authority, **kwargs)  # noqa: E501
            return data

    def get_all_toolpermissions_with_http_info(self, authority, **kwargs):  # noqa: E501
        """get all toolpermissions for an authority  # noqa: E501

        Returns explicit (rights set for this authority) + effective (resulting rights for this authority) toolpermission  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_toolpermissions_with_http_info(authority, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authority: Authority to load (user or group) (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authority']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_toolpermissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authority' is set
        if ('authority' not in params or
                params['authority'] is None):
            raise ValueError("Missing the required parameter `authority` when calling `get_all_toolpermissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'authority' in params:
            path_params['authority'] = params['authority']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/toolpermissions/{authority}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_xml(self, xml, **kwargs):  # noqa: E501
        """list any xml properties (like from homeApplication.properties.xml)  # noqa: E501

        list any xml properties (like from homeApplication.properties.xml)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_xml(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: Properties Filename (*.xml) (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_xml_with_http_info(xml, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_xml_with_http_info(xml, **kwargs)  # noqa: E501
            return data

    def get_application_xml_with_http_info(self, xml, **kwargs):  # noqa: E501
        """list any xml properties (like from homeApplication.properties.xml)  # noqa: E501

        list any xml properties (like from homeApplication.properties.xml)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_xml_with_http_info(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: Properties Filename (*.xml) (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['xml']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'xml' is set
        if ('xml' not in params or
                params['xml'] is None):
            raise ValueError("Missing the required parameter `xml` when calling `get_application_xml`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'xml' in params:
            path_params['xml'] = params['xml']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applications/{xml}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applications(self, **kwargs):  # noqa: E501
        """list applications  # noqa: E501

        List all registered applications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_applications_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_applications_with_http_info(self, **kwargs):  # noqa: E501
        """list applications  # noqa: E501

        List all registered applications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Application]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applications" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Application]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cache_info(self, id, **kwargs):  # noqa: E501
        """Get information about a cache  # noqa: E501

        Get information about a cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cache_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id/bean name of the cache (required)
        :return: CacheInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cache_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cache_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_cache_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get information about a cache  # noqa: E501

        Get information about a cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cache_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id/bean name of the cache (required)
        :return: CacheInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cache_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_cache_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/cache/cacheInfo/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CacheInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_catalina_out(self, **kwargs):  # noqa: E501
        """Get last info from catalina out  # noqa: E501

        Get catalina.out log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_catalina_out(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_catalina_out_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_catalina_out_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_catalina_out_with_http_info(self, **kwargs):  # noqa: E501
        """Get last info from catalina out  # noqa: E501

        Get catalina.out log.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_catalina_out_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_catalina_out" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/catalina', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster(self, **kwargs):  # noqa: E501
        """Get information about the Cluster  # noqa: E501

        Get information the Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CacheCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_cluster_with_http_info(self, **kwargs):  # noqa: E501
        """Get information about the Cluster  # noqa: E501

        Get information the Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CacheCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/clusterInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CacheCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_clusters(self, **kwargs):  # noqa: E501
        """Get information about the Cluster  # noqa: E501

        Get information the Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clusters(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CacheCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_clusters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_clusters_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_clusters_with_http_info(self, **kwargs):  # noqa: E501
        """Get information about the Cluster  # noqa: E501

        Get information the Cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clusters_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CacheCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clusters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/clusterInfos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CacheCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config(self, **kwargs):  # noqa: E501
        """set/update the repository config object  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryConfig body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_config_with_http_info(self, **kwargs):  # noqa: E501
        """set/update the repository config object  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryConfig body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/repositoryConfig', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_file(self, filename, **kwargs):  # noqa: E501
        """get a base system config file (e.g. edu-sharing.conf)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_file(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filename: filename to fetch (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_file_with_http_info(filename, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_file_with_http_info(filename, **kwargs)  # noqa: E501
            return data

    def get_config_file_with_http_info(self, filename, **kwargs):  # noqa: E501
        """get a base system config file (e.g. edu-sharing.conf)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_file_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filename: filename to fetch (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `get_config_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/configFile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_global_groups(self, **kwargs):  # noqa: E501
        """Get global groups  # noqa: E501

        Get global groups (groups across repositories).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_global_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Group]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_global_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_global_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_global_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Get global groups  # noqa: E501

        Get global groups (groups across repositories).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_global_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Group]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_global_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/globalGroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Group]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_jobs(self, **kwargs):  # noqa: E501
        """get all running jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[JobInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_jobs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_jobs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """get all running jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_jobs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[JobInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[JobInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_oai_classes(self, **kwargs):  # noqa: E501
        """Get OAI class names  # noqa: E501

        Get available importer classes for OAI import.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oai_classes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_oai_classes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_oai_classes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_oai_classes_with_http_info(self, **kwargs):  # noqa: E501
        """Get OAI class names  # noqa: E501

        Get available importer classes for OAI import.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oai_classes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_oai_classes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/oai/classes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_property_to_mds(self, properties, **kwargs):  # noqa: E501
        """Get a Mds Valuespace for all values of the given properties  # noqa: E501

        Get a Mds Valuespace for all values of the given properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_to_mds(properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] properties: one or more properties (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_property_to_mds_with_http_info(properties, **kwargs)  # noqa: E501
        else:
            (data) = self.get_property_to_mds_with_http_info(properties, **kwargs)  # noqa: E501
            return data

    def get_property_to_mds_with_http_info(self, properties, **kwargs):  # noqa: E501
        """Get a Mds Valuespace for all values of the given properties  # noqa: E501

        Get a Mds Valuespace for all values of the given properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_to_mds_with_http_info(properties, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] properties: one or more properties (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['properties']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_property_to_mds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'properties' is set
        if ('properties' not in params or
                params['properties'] is None):
            raise ValueError("Missing the required parameter `properties` when calling `get_property_to_mds`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'properties' in params:
            query_params.append(('properties', params['properties']))  # noqa: E501
            collection_formats['properties'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/propertyToMds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_statistics(self, **kwargs):  # noqa: E501
        """get statistics  # noqa: E501

        get statistics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_statistics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AdminStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_statistics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_statistics_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_statistics_with_http_info(self, **kwargs):  # noqa: E501
        """get statistics  # noqa: E501

        get statistics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_statistics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AdminStatistics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_statistics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminStatistics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_collections(self, xml, **kwargs):  # noqa: E501
        """import collections via a xml file  # noqa: E501

        xml file must be structured as defined by the xsd standard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_collections(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: (required)
        :param str parent: Id of the root to initialize the collection structure, or '-root-' to inflate them on the first level
        :return: CollectionsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_collections_with_http_info(xml, **kwargs)  # noqa: E501
        else:
            (data) = self.import_collections_with_http_info(xml, **kwargs)  # noqa: E501
            return data

    def import_collections_with_http_info(self, xml, **kwargs):  # noqa: E501
        """import collections via a xml file  # noqa: E501

        xml file must be structured as defined by the xsd standard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_collections_with_http_info(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: (required)
        :param str parent: Id of the root to initialize the collection structure, or '-root-' to inflate them on the first level
        :return: CollectionsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['xml', 'parent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_collections" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'xml' is set
        if ('xml' not in params or
                params['xml'] is None):
            raise ValueError("Missing the required parameter `xml` when calling `import_collections`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parent' in params:
            query_params.append(('parent', params['parent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'xml' in params:
            local_var_files['xml'] = params['xml']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/collections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CollectionsResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_excel(self, excel, parent, **kwargs):  # noqa: E501
        """Import excel data  # noqa: E501

        Import excel data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_excel(excel, parent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str excel: (required)
        :param str parent: parent (required)
        :return: ExcelResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_excel_with_http_info(excel, parent, **kwargs)  # noqa: E501
        else:
            (data) = self.import_excel_with_http_info(excel, parent, **kwargs)  # noqa: E501
            return data

    def import_excel_with_http_info(self, excel, parent, **kwargs):  # noqa: E501
        """Import excel data  # noqa: E501

        Import excel data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_excel_with_http_info(excel, parent, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str excel: (required)
        :param str parent: parent (required)
        :return: ExcelResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['excel', 'parent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_excel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'excel' is set
        if ('excel' not in params or
                params['excel'] is None):
            raise ValueError("Missing the required parameter `excel` when calling `import_excel`")  # noqa: E501
        # verify the required parameter 'parent' is set
        if ('parent' not in params or
                params['parent'] is None):
            raise ValueError("Missing the required parameter `parent` when calling `import_excel`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parent' in params:
            query_params.append(('parent', params['parent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'excel' in params:
            local_var_files['excel'] = params['excel']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/excel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExcelResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_oai(self, base_url, set, metadata_prefix, class_name, **kwargs):  # noqa: E501
        """Import oai data  # noqa: E501

        Import oai data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_oai(base_url, set, metadata_prefix, class_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base_url: base url (required)
        :param str set: set/catalog id (required)
        :param str metadata_prefix: metadata prefix (required)
        :param str class_name: importer job class name (call /classes to obtain a list) (required)
        :param str metadataset: id metadataset
        :param str importer_class_name: importer class name (call /classes to obtain a list)
        :param str record_handler_class_name: RecordHandler class name
        :param str binary_handler_class_name: BinaryHandler class name (may be empty for none)
        :param str file_url: url to file
        :param str oai_ids: OAI Ids to import, can be null than the whole set will be imported
        :param bool force_update: force Update of all entries
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_oai_with_http_info(base_url, set, metadata_prefix, class_name, **kwargs)  # noqa: E501
        else:
            (data) = self.import_oai_with_http_info(base_url, set, metadata_prefix, class_name, **kwargs)  # noqa: E501
            return data

    def import_oai_with_http_info(self, base_url, set, metadata_prefix, class_name, **kwargs):  # noqa: E501
        """Import oai data  # noqa: E501

        Import oai data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_oai_with_http_info(base_url, set, metadata_prefix, class_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base_url: base url (required)
        :param str set: set/catalog id (required)
        :param str metadata_prefix: metadata prefix (required)
        :param str class_name: importer job class name (call /classes to obtain a list) (required)
        :param str metadataset: id metadataset
        :param str importer_class_name: importer class name (call /classes to obtain a list)
        :param str record_handler_class_name: RecordHandler class name
        :param str binary_handler_class_name: BinaryHandler class name (may be empty for none)
        :param str file_url: url to file
        :param str oai_ids: OAI Ids to import, can be null than the whole set will be imported
        :param bool force_update: force Update of all entries
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_url', 'set', 'metadata_prefix', 'class_name', 'metadataset', 'importer_class_name', 'record_handler_class_name', 'binary_handler_class_name', 'file_url', 'oai_ids', 'force_update']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_oai" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_url' is set
        if ('base_url' not in params or
                params['base_url'] is None):
            raise ValueError("Missing the required parameter `base_url` when calling `import_oai`")  # noqa: E501
        # verify the required parameter 'set' is set
        if ('set' not in params or
                params['set'] is None):
            raise ValueError("Missing the required parameter `set` when calling `import_oai`")  # noqa: E501
        # verify the required parameter 'metadata_prefix' is set
        if ('metadata_prefix' not in params or
                params['metadata_prefix'] is None):
            raise ValueError("Missing the required parameter `metadata_prefix` when calling `import_oai`")  # noqa: E501
        # verify the required parameter 'class_name' is set
        if ('class_name' not in params or
                params['class_name'] is None):
            raise ValueError("Missing the required parameter `class_name` when calling `import_oai`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'base_url' in params:
            query_params.append(('baseUrl', params['base_url']))  # noqa: E501
        if 'set' in params:
            query_params.append(('set', params['set']))  # noqa: E501
        if 'metadata_prefix' in params:
            query_params.append(('metadataPrefix', params['metadata_prefix']))  # noqa: E501
        if 'metadataset' in params:
            query_params.append(('metadataset', params['metadataset']))  # noqa: E501
        if 'class_name' in params:
            query_params.append(('className', params['class_name']))  # noqa: E501
        if 'importer_class_name' in params:
            query_params.append(('importerClassName', params['importer_class_name']))  # noqa: E501
        if 'record_handler_class_name' in params:
            query_params.append(('recordHandlerClassName', params['record_handler_class_name']))  # noqa: E501
        if 'binary_handler_class_name' in params:
            query_params.append(('binaryHandlerClassName', params['binary_handler_class_name']))  # noqa: E501
        if 'file_url' in params:
            query_params.append(('fileUrl', params['file_url']))  # noqa: E501
        if 'oai_ids' in params:
            query_params.append(('oaiIds', params['oai_ids']))  # noqa: E501
        if 'force_update' in params:
            query_params.append(('forceUpdate', params['force_update']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/oai', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_oai_xml(self, **kwargs):  # noqa: E501
        """Import single xml via oai (for testing)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_oai_xml(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml:
        :param str record_handler_class_name: RecordHandler class name
        :param str binary_handler_class_name: BinaryHandler class name (may be empty for none)
        :return: Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_oai_xml_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_oai_xml_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_oai_xml_with_http_info(self, **kwargs):  # noqa: E501
        """Import single xml via oai (for testing)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_oai_xml_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml:
        :param str record_handler_class_name: RecordHandler class name
        :param str binary_handler_class_name: BinaryHandler class name (may be empty for none)
        :return: Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['xml', 'record_handler_class_name', 'binary_handler_class_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_oai_xml" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'record_handler_class_name' in params:
            query_params.append(('recordHandlerClassName', params['record_handler_class_name']))  # noqa: E501
        if 'binary_handler_class_name' in params:
            query_params.append(('binaryHandlerClassName', params['binary_handler_class_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'xml' in params:
            local_var_files['xml'] = params['xml']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/oai/xml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Node',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_app_info(self, **kwargs):  # noqa: E501
        """refresh app info  # noqa: E501

        Refresh the application info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_app_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_app_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.refresh_app_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def refresh_app_info_with_http_info(self, **kwargs):  # noqa: E501
        """refresh app info  # noqa: E501

        Refresh the application info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_app_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_app_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/refreshAppInfo', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_cache(self, folder, sticky, **kwargs):  # noqa: E501
        """Refresh cache  # noqa: E501

        Refresh importer cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_cache(folder, sticky, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder: refresh cache root folder id (required)
        :param bool sticky: sticky (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_cache_with_http_info(folder, sticky, **kwargs)  # noqa: E501
        else:
            (data) = self.refresh_cache_with_http_info(folder, sticky, **kwargs)  # noqa: E501
            return data

    def refresh_cache_with_http_info(self, folder, sticky, **kwargs):  # noqa: E501
        """Refresh cache  # noqa: E501

        Refresh importer cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_cache_with_http_info(folder, sticky, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder: refresh cache root folder id (required)
        :param bool sticky: sticky (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder', 'sticky']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_cache" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder' is set
        if ('folder' not in params or
                params['folder'] is None):
            raise ValueError("Missing the required parameter `folder` when calling `refresh_cache`")  # noqa: E501
        # verify the required parameter 'sticky' is set
        if ('sticky' not in params or
                params['sticky'] is None):
            raise ValueError("Missing the required parameter `sticky` when calling `refresh_cache`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder' in params:
            path_params['folder'] = params['folder']  # noqa: E501

        query_params = []
        if 'sticky' in params:
            query_params.append(('sticky', params['sticky']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/refreshCache/{folder}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_edu_group_cache(self, **kwargs):  # noqa: E501
        """Refresh the Edu Group Cache  # noqa: E501

        Refresh the Edu Group Cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_edu_group_cache(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool keep_existing: keep existing
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_edu_group_cache_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.refresh_edu_group_cache_with_http_info(**kwargs)  # noqa: E501
            return data

    def refresh_edu_group_cache_with_http_info(self, **kwargs):  # noqa: E501
        """Refresh the Edu Group Cache  # noqa: E501

        Refresh the Edu Group Cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_edu_group_cache_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool keep_existing: keep existing
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['keep_existing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_edu_group_cache" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'keep_existing' in params:
            query_params.append(('keepExisting', params['keep_existing']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/cache/refreshEduGroupCache', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_application(self, id, **kwargs):  # noqa: E501
        """remove an application  # noqa: E501

        remove the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_application(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_application_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_application_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def remove_application_with_http_info(self, id, **kwargs):  # noqa: E501
        """remove an application  # noqa: E501

        remove the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_application_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Application id (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applications/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_cache_entry(self, **kwargs):  # noqa: E501
        """remove cache entry  # noqa: E501

        remove cache entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_cache_entry(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cache_index: cacheIndex
        :param str bean: bean
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_cache_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_cache_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_cache_entry_with_http_info(self, **kwargs):  # noqa: E501
        """remove cache entry  # noqa: E501

        remove cache entry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_cache_entry_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int cache_index: cacheIndex
        :param str bean: bean
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cache_index', 'bean']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_cache_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'cache_index' in params:
            query_params.append(('cacheIndex', params['cache_index']))  # noqa: E501
        if 'bean' in params:
            query_params.append(('bean', params['bean']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/cache/removeCacheEntry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_oai_imports(self, base_url, set, metadata_prefix, **kwargs):  # noqa: E501
        """Remove deleted imports  # noqa: E501

        Remove deleted imports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_oai_imports(base_url, set, metadata_prefix, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base_url: base url (required)
        :param str set: set/catalog id (required)
        :param str metadata_prefix: metadata prefix (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_oai_imports_with_http_info(base_url, set, metadata_prefix, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_oai_imports_with_http_info(base_url, set, metadata_prefix, **kwargs)  # noqa: E501
            return data

    def remove_oai_imports_with_http_info(self, base_url, set, metadata_prefix, **kwargs):  # noqa: E501
        """Remove deleted imports  # noqa: E501

        Remove deleted imports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_oai_imports_with_http_info(base_url, set, metadata_prefix, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base_url: base url (required)
        :param str set: set/catalog id (required)
        :param str metadata_prefix: metadata prefix (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_url', 'set', 'metadata_prefix']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_oai_imports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_url' is set
        if ('base_url' not in params or
                params['base_url'] is None):
            raise ValueError("Missing the required parameter `base_url` when calling `remove_oai_imports`")  # noqa: E501
        # verify the required parameter 'set' is set
        if ('set' not in params or
                params['set'] is None):
            raise ValueError("Missing the required parameter `set` when calling `remove_oai_imports`")  # noqa: E501
        # verify the required parameter 'metadata_prefix' is set
        if ('metadata_prefix' not in params or
                params['metadata_prefix'] is None):
            raise ValueError("Missing the required parameter `metadata_prefix` when calling `remove_oai_imports`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'base_url' in params:
            query_params.append(('baseUrl', params['base_url']))  # noqa: E501
        if 'set' in params:
            query_params.append(('set', params['set']))  # noqa: E501
        if 'metadata_prefix' in params:
            query_params.append(('metadataPrefix', params['metadata_prefix']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/import/oai', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_by_lucene(self, **kwargs):  # noqa: E501
        """Search for custom lucene query  # noqa: E501

        e.g. @cm\\:name:\"*\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_by_lucene(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: query
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :param list[str] authority_scope: authority scope to search for
        :return: SearchResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_by_lucene_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_by_lucene_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_by_lucene_with_http_info(self, **kwargs):  # noqa: E501
        """Search for custom lucene query  # noqa: E501

        e.g. @cm\\:name:\"*\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_by_lucene_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: query
        :param int max_items: maximum items per page
        :param int skip_count: skip a number of items
        :param list[str] sort_properties: sort properties
        :param list[bool] sort_ascending: sort ascending, true if not set. Use multiple values to change the direction according to the given property at the same index
        :param list[str] property_filter: property filter for result nodes (or \"-all-\" for all properties)
        :param list[str] authority_scope: authority scope to search for
        :return: SearchResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query', 'max_items', 'skip_count', 'sort_properties', 'sort_ascending', 'property_filter', 'authority_scope']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_by_lucene" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'max_items' in params:
            query_params.append(('maxItems', params['max_items']))  # noqa: E501
        if 'skip_count' in params:
            query_params.append(('skipCount', params['skip_count']))  # noqa: E501
        if 'sort_properties' in params:
            query_params.append(('sortProperties', params['sort_properties']))  # noqa: E501
            collection_formats['sortProperties'] = 'multi'  # noqa: E501
        if 'sort_ascending' in params:
            query_params.append(('sortAscending', params['sort_ascending']))  # noqa: E501
            collection_formats['sortAscending'] = 'multi'  # noqa: E501
        if 'property_filter' in params:
            query_params.append(('propertyFilter', params['property_filter']))  # noqa: E501
            collection_formats['propertyFilter'] = 'multi'  # noqa: E501
        if 'authority_scope' in params:
            query_params.append(('authorityScope', params['authority_scope']))  # noqa: E501
            collection_formats['authorityScope'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/lucene', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def server_update_list(self, **kwargs):  # noqa: E501
        """list available update tasks  # noqa: E501

        list available update tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.server_update_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ServerUpdateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.server_update_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.server_update_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def server_update_list_with_http_info(self, **kwargs):  # noqa: E501
        """list available update tasks  # noqa: E501

        list available update tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.server_update_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ServerUpdateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method server_update_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/serverUpdate/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ServerUpdateInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def server_update_list_0(self, id, execute, **kwargs):  # noqa: E501
        """Run an update tasks  # noqa: E501

        Run a specific update task (test or full update).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.server_update_list_0(id, execute, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the update task (required)
        :param bool execute: Actually execute (if false, just runs in test mode) (required)
        :return: list[ServerUpdateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.server_update_list_0_with_http_info(id, execute, **kwargs)  # noqa: E501
        else:
            (data) = self.server_update_list_0_with_http_info(id, execute, **kwargs)  # noqa: E501
            return data

    def server_update_list_0_with_http_info(self, id, execute, **kwargs):  # noqa: E501
        """Run an update tasks  # noqa: E501

        Run a specific update task (test or full update).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.server_update_list_0_with_http_info(id, execute, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the update task (required)
        :param bool execute: Actually execute (if false, just runs in test mode) (required)
        :return: list[ServerUpdateInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'execute']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method server_update_list_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `server_update_list_0`")  # noqa: E501
        # verify the required parameter 'execute' is set
        if ('execute' not in params or
                params['execute'] is None):
            raise ValueError("Missing the required parameter `execute` when calling `server_update_list_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'execute' in params:
            query_params.append(('execute', params['execute']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/serverUpdate/run/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ServerUpdateInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_config(self, **kwargs):  # noqa: E501
        """get the repository config object  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_config(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RepositoryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_config_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.set_config_with_http_info(**kwargs)  # noqa: E501
            return data

    def set_config_with_http_info(self, **kwargs):  # noqa: E501
        """get the repository config object  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RepositoryConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_config" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/repositoryConfig', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepositoryConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_toolpermissions(self, authority, **kwargs):  # noqa: E501
        """set toolpermissions for an authority  # noqa: E501

        If a toolpermission has status UNDEFINED, it will remove explicit permissions for the authority  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_toolpermissions(authority, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authority: Authority to set (user or group) (required)
        :param dict(str, str) body:
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_toolpermissions_with_http_info(authority, **kwargs)  # noqa: E501
        else:
            (data) = self.set_toolpermissions_with_http_info(authority, **kwargs)  # noqa: E501
            return data

    def set_toolpermissions_with_http_info(self, authority, **kwargs):  # noqa: E501
        """set toolpermissions for an authority  # noqa: E501

        If a toolpermission has status UNDEFINED, it will remove explicit permissions for the authority  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_toolpermissions_with_http_info(authority, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authority: Authority to set (user or group) (required)
        :param dict(str, str) body:
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authority', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_toolpermissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authority' is set
        if ('authority' not in params or
                params['authority'] is None):
            raise ValueError("Missing the required parameter `authority` when calling `set_toolpermissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'authority' in params:
            path_params['authority'] = params['authority']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/toolpermissions/{authority}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_job(self, body, job_class, **kwargs):  # noqa: E501
        """Start a Job.  # noqa: E501

        Start a Job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_job(body, job_class, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, str) body: params (required)
        :param str job_class: jobClass (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_job_with_http_info(body, job_class, **kwargs)  # noqa: E501
        else:
            (data) = self.start_job_with_http_info(body, job_class, **kwargs)  # noqa: E501
            return data

    def start_job_with_http_info(self, body, job_class, **kwargs):  # noqa: E501
        """Start a Job.  # noqa: E501

        Start a Job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_job_with_http_info(body, job_class, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, str) body: params (required)
        :param str job_class: jobClass (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'job_class']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `start_job`")  # noqa: E501
        # verify the required parameter 'job_class' is set
        if ('job_class' not in params or
                params['job_class'] is None):
            raise ValueError("Missing the required parameter `job_class` when calling `start_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_class' in params:
            path_params['jobClass'] = params['job_class']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/job/{jobClass}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_mail(self, receiver, template, **kwargs):  # noqa: E501
        """Test a mail template  # noqa: E501

        Sends the given template as a test to the given receiver.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_mail(receiver, template, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str receiver: (required)
        :param str template: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_mail_with_http_info(receiver, template, **kwargs)  # noqa: E501
        else:
            (data) = self.test_mail_with_http_info(receiver, template, **kwargs)  # noqa: E501
            return data

    def test_mail_with_http_info(self, receiver, template, **kwargs):  # noqa: E501
        """Test a mail template  # noqa: E501

        Sends the given template as a test to the given receiver.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_mail_with_http_info(receiver, template, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str receiver: (required)
        :param str template: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['receiver', 'template']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_mail" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'receiver' is set
        if ('receiver' not in params or
                params['receiver'] is None):
            raise ValueError("Missing the required parameter `receiver` when calling `test_mail`")  # noqa: E501
        # verify the required parameter 'template' is set
        if ('template' not in params or
                params['template'] is None):
            raise ValueError("Missing the required parameter `template` when calling `test_mail`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'receiver' in params:
            path_params['receiver'] = params['receiver']  # noqa: E501
        if 'template' in params:
            path_params['template'] = params['template']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/mail/{receiver}/{template}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_application_xml(self, xml, **kwargs):  # noqa: E501
        """edit any properties xml (like homeApplication.properties.xml)  # noqa: E501

        if the key exists, it will be overwritten. Otherwise, it will be created. You only need to transfer keys you want to edit  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application_xml(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: Properties Filename (*.xml) (required)
        :param dict(str, str) body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_application_xml_with_http_info(xml, **kwargs)  # noqa: E501
        else:
            (data) = self.update_application_xml_with_http_info(xml, **kwargs)  # noqa: E501
            return data

    def update_application_xml_with_http_info(self, xml, **kwargs):  # noqa: E501
        """edit any properties xml (like homeApplication.properties.xml)  # noqa: E501

        if the key exists, it will be overwritten. Otherwise, it will be created. You only need to transfer keys you want to edit  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_application_xml_with_http_info(xml, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str xml: Properties Filename (*.xml) (required)
        :param dict(str, str) body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['xml', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_application_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'xml' is set
        if ('xml' not in params or
                params['xml'] is None):
            raise ValueError("Missing the required parameter `xml` when calling `update_application_xml`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'xml' in params:
            path_params['xml'] = params['xml']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/applications/{xml}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_config_file(self, filename, **kwargs):  # noqa: E501
        """update a base system config file (e.g. edu-sharing.conf)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_file(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filename: filename to fetch (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_config_file_with_http_info(filename, **kwargs)  # noqa: E501
        else:
            (data) = self.update_config_file_with_http_info(filename, **kwargs)  # noqa: E501
            return data

    def update_config_file_with_http_info(self, filename, **kwargs):  # noqa: E501
        """update a base system config file (e.g. edu-sharing.conf)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_file_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filename: filename to fetch (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filename', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_config_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `update_config_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/configFile', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_temp(self, file, name, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        Upload a file to tomcat temp directory, to use it on the server (e.g. an update)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_temp(file, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str name: filename (required)
        :return: UploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_temp_with_http_info(file, name, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_temp_with_http_info(file, name, **kwargs)  # noqa: E501
            return data

    def upload_temp_with_http_info(self, file, name, **kwargs):  # noqa: E501
        """Upload a file  # noqa: E501

        Upload a file to tomcat temp directory, to use it on the server (e.g. an update)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_temp_with_http_info(file, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str name: filename (required)
        :return: UploadResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_temp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_temp`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `upload_temp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/admin/v1/upload/temp/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
